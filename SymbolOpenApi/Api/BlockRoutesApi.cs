/*
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using RestSharp;
using SymbolOpenApi.Client;
using SymbolOpenApi.Model;

namespace SymbolOpenApi.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBlockRoutesApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <returns>BlockInfoDTO</returns>
        BlockInfoDTO GetBlockByHeight (string height);

        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <returns>ApiResponse of BlockInfoDTO</returns>
        ApiResponse<BlockInfoDTO> GetBlockByHeightWithHttpInfo (string height);
        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        MerkleProofInfoDTO GetMerkleReceipts (string height, string hash);

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        ApiResponse<MerkleProofInfoDTO> GetMerkleReceiptsWithHttpInfo (string height, string hash);
        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        MerkleProofInfoDTO GetMerkleTransaction (string height, string hash);

        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        ApiResponse<MerkleProofInfoDTO> GetMerkleTransactionWithHttpInfo (string height, string hash);
        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <returns>BlockPage</returns>
        BlockPage SearchBlocks (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?));

        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <returns>ApiResponse of BlockPage</returns>
        ApiResponse<BlockPage> SearchBlocksWithHttpInfo (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of BlockInfoDTO</returns>
        System.Threading.Tasks.Task<BlockInfoDTO> GetBlockByHeightAsync (string height, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (BlockInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<BlockInfoDTO>> GetBlockByHeightWithHttpInfoAsync (string height, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleReceiptsAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleReceiptsWithHttpInfoAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleTransactionAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleTransactionWithHttpInfoAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of BlockPage</returns>
        System.Threading.Tasks.Task<BlockPage> SearchBlocksAsync (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (BlockPage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BlockPage>> SearchBlocksWithHttpInfoAsync (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BlockRoutesApi : IBlockRoutesApi
    {
        private SymbolOpenApi.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BlockRoutesApi(String basePath)
        {
            this.Configuration = new SymbolOpenApi.Client.Configuration { BasePath = basePath };

            ExceptionFactory = SymbolOpenApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class
        /// </summary>
        /// <returns></returns>
        public BlockRoutesApi()
        {
            this.Configuration = SymbolOpenApi.Client.Configuration.Default;

            ExceptionFactory = SymbolOpenApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public BlockRoutesApi(SymbolOpenApi.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = SymbolOpenApi.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = SymbolOpenApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public SymbolOpenApi.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public SymbolOpenApi.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <returns>BlockInfoDTO</returns>
        public BlockInfoDTO GetBlockByHeight (string height)
        {
             ApiResponse<BlockInfoDTO> localVarResponse = GetBlockByHeightWithHttpInfo(height);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <returns>ApiResponse of BlockInfoDTO</returns>
        public ApiResponse<BlockInfoDTO> GetBlockByHeightWithHttpInfo (string height)
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetBlockByHeight");

            var localVarPath = "/blocks/{height}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBlockByHeight", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BlockInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BlockInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BlockInfoDTO)));
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of BlockInfoDTO</returns>
        public async System.Threading.Tasks.Task<BlockInfoDTO> GetBlockByHeightAsync (string height, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<BlockInfoDTO> localVarResponse = await GetBlockByHeightWithHttpInfoAsync(height, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (BlockInfoDTO)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BlockInfoDTO>> GetBlockByHeightWithHttpInfoAsync (string height, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetBlockByHeight");

            var localVarPath = "/blocks/{height}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBlockByHeight", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BlockInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BlockInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BlockInfoDTO)));
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        public MerkleProofInfoDTO GetMerkleReceipts (string height, string hash)
        {
             ApiResponse<MerkleProofInfoDTO> localVarResponse = GetMerkleReceiptsWithHttpInfo(height, hash);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        public ApiResponse<MerkleProofInfoDTO> GetMerkleReceiptsWithHttpInfo (string height, string hash)
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleReceipts");
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleReceipts");

            var localVarPath = "/blocks/{height}/statements/{hash}/merkle";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter
            if (hash != null) localVarPathParams.Add("hash", this.Configuration.ApiClient.ParameterToString(hash)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetMerkleReceipts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MerkleProofInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MerkleProofInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MerkleProofInfoDTO)));
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        public async System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleReceiptsAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<MerkleProofInfoDTO> localVarResponse = await GetMerkleReceiptsWithHttpInfoAsync(height, hash, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleReceiptsWithHttpInfoAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleReceipts");
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleReceipts");

            var localVarPath = "/blocks/{height}/statements/{hash}/merkle";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter
            if (hash != null) localVarPathParams.Add("hash", this.Configuration.ApiClient.ParameterToString(hash)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetMerkleReceipts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MerkleProofInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MerkleProofInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MerkleProofInfoDTO)));
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        public MerkleProofInfoDTO GetMerkleTransaction (string height, string hash)
        {
             ApiResponse<MerkleProofInfoDTO> localVarResponse = GetMerkleTransactionWithHttpInfo(height, hash);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        public ApiResponse<MerkleProofInfoDTO> GetMerkleTransactionWithHttpInfo (string height, string hash)
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleTransaction");
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleTransaction");

            var localVarPath = "/blocks/{height}/transactions/{hash}/merkle";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter
            if (hash != null) localVarPathParams.Add("hash", this.Configuration.ApiClient.ParameterToString(hash)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetMerkleTransaction", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MerkleProofInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MerkleProofInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MerkleProofInfoDTO)));
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        public async System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleTransactionAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<MerkleProofInfoDTO> localVarResponse = await GetMerkleTransactionWithHttpInfoAsync(height, hash, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleTransactionWithHttpInfoAsync (string height, string hash, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
                throw new ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleTransaction");
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleTransaction");

            var localVarPath = "/blocks/{height}/transactions/{hash}/merkle";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (height != null) localVarPathParams.Add("height", this.Configuration.ApiClient.ParameterToString(height)); // path parameter
            if (hash != null) localVarPathParams.Add("hash", this.Configuration.ApiClient.ParameterToString(hash)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetMerkleTransaction", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MerkleProofInfoDTO>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MerkleProofInfoDTO) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MerkleProofInfoDTO)));
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <returns>BlockPage</returns>
        public BlockPage SearchBlocks (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?))
        {
             ApiResponse<BlockPage> localVarResponse = SearchBlocksWithHttpInfo(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <returns>ApiResponse of BlockPage</returns>
        public ApiResponse<BlockPage> SearchBlocksWithHttpInfo (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?))
        {

            var localVarPath = "/blocks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (signerPublicKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "signerPublicKey", signerPublicKey)); // query parameter
            if (beneficiaryAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "beneficiaryAddress", beneficiaryAddress)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            if (pageNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageNumber", pageNumber)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (order != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order", order)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orderBy", orderBy)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchBlocks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BlockPage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BlockPage) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BlockPage)));
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of BlockPage</returns>
        public async System.Threading.Tasks.Task<BlockPage> SearchBlocksAsync (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<BlockPage> localVarResponse = await SearchBlocksWithHttpInfoAsync(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolOpenApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (BlockPage)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BlockPage>> SearchBlocksWithHttpInfoAsync (string signerPublicKey = default(string), string beneficiaryAddress = default(string), int? pageSize = default(int?), int? pageNumber = default(int?), string offset = default(string), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), CancellationToken cancellationToken = default(CancellationToken))
        {

            var localVarPath = "/blocks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (signerPublicKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "signerPublicKey", signerPublicKey)); // query parameter
            if (beneficiaryAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "beneficiaryAddress", beneficiaryAddress)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            if (pageNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageNumber", pageNumber)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (order != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order", order)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orderBy", orderBy)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchBlocks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BlockPage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BlockPage) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BlockPage)));
        }

    }
}
