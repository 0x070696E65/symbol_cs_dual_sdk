/*
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = SymbolOpenApi.Client.OpenAPIDateConverter;

namespace SymbolOpenApi.Model
{
    /// <summary>
    /// Chain related configuration properties.
    /// </summary>
    [DataContract]
    public partial class ChainPropertiesDTO :  IEquatable<ChainPropertiesDTO>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChainPropertiesDTO" /> class.
        /// </summary>
        /// <param name="enableVerifiableState">Set to true if block chain should calculate state hashes so that state is fully verifiable at each block..</param>
        /// <param name="enableVerifiableReceipts">Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block..</param>
        /// <param name="currencyMosaicId">Mosaic id used as primary chain currency..</param>
        /// <param name="harvestingMosaicId">Mosaic id used to provide harvesting ability..</param>
        /// <param name="blockGenerationTargetTime">Targeted time between blocks..</param>
        /// <param name="blockTimeSmoothingFactor">A higher value makes the network more biased..</param>
        /// <param name="blockFinalizationInterval">Number of blocks between successive finalization attempts..</param>
        /// <param name="importanceGrouping">Number of blocks that should be treated as a group for importance purposes..</param>
        /// <param name="importanceActivityPercentage">Percentage of importance resulting from fee generation and beneficiary usage..</param>
        /// <param name="maxRollbackBlocks">Maximum number of blocks that can be rolled back..</param>
        /// <param name="maxDifficultyBlocks">Maximum number of blocks to use in a difficulty calculation..</param>
        /// <param name="defaultDynamicFeeMultiplier">Default multiplier to use for dynamic fees..</param>
        /// <param name="maxTransactionLifetime">Maximum lifetime a transaction can have before it expires..</param>
        /// <param name="maxBlockFutureTime">Maximum future time of a block that can be accepted..</param>
        /// <param name="initialCurrencyAtomicUnits">Initial currency atomic units available in the network..</param>
        /// <param name="maxMosaicAtomicUnits">Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network..</param>
        /// <param name="totalChainImportance">Total whole importance units available in the network..</param>
        /// <param name="minHarvesterBalance">Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting..</param>
        /// <param name="maxHarvesterBalance">Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting..</param>
        /// <param name="minVoterBalance">Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting..</param>
        /// <param name="maxVotingKeysPerAccount">Maximum number of voting keys that can be registered at once per account..</param>
        /// <param name="minVotingKeyLifetime">Minimum number of finalization rounds for which voting key can be registered..</param>
        /// <param name="maxVotingKeyLifetime">Maximum number of finalization rounds for which voting key can be registered..</param>
        /// <param name="harvestBeneficiaryPercentage">Percentage of the harvested fee that is collected by the beneficiary account..</param>
        /// <param name="harvestNetworkPercentage">Percentage of the harvested fee that is collected by the network..</param>
        /// <param name="harvestNetworkFeeSinkAddress">Address encoded using a 32-character set..</param>
        /// <param name="blockPruneInterval">Number of blocks between cache pruning..</param>
        /// <param name="maxTransactionsPerBlock">Maximum number of transactions per block..</param>
        public ChainPropertiesDTO(bool enableVerifiableState = default(bool), bool enableVerifiableReceipts = default(bool), string currencyMosaicId = default(string), string harvestingMosaicId = default(string), string blockGenerationTargetTime = default(string), string blockTimeSmoothingFactor = default(string), string blockFinalizationInterval = default(string), string importanceGrouping = default(string), string importanceActivityPercentage = default(string), string maxRollbackBlocks = default(string), string maxDifficultyBlocks = default(string), string defaultDynamicFeeMultiplier = default(string), string maxTransactionLifetime = default(string), string maxBlockFutureTime = default(string), string initialCurrencyAtomicUnits = default(string), string maxMosaicAtomicUnits = default(string), string totalChainImportance = default(string), string minHarvesterBalance = default(string), string maxHarvesterBalance = default(string), string minVoterBalance = default(string), string maxVotingKeysPerAccount = default(string), string minVotingKeyLifetime = default(string), string maxVotingKeyLifetime = default(string), string harvestBeneficiaryPercentage = default(string), string harvestNetworkPercentage = default(string), string harvestNetworkFeeSinkAddress = default(string), string blockPruneInterval = default(string), string maxTransactionsPerBlock = default(string))
        {
            this.EnableVerifiableState = enableVerifiableState;
            this.EnableVerifiableReceipts = enableVerifiableReceipts;
            this.CurrencyMosaicId = currencyMosaicId;
            this.HarvestingMosaicId = harvestingMosaicId;
            this.BlockGenerationTargetTime = blockGenerationTargetTime;
            this.BlockTimeSmoothingFactor = blockTimeSmoothingFactor;
            this.BlockFinalizationInterval = blockFinalizationInterval;
            this.ImportanceGrouping = importanceGrouping;
            this.ImportanceActivityPercentage = importanceActivityPercentage;
            this.MaxRollbackBlocks = maxRollbackBlocks;
            this.MaxDifficultyBlocks = maxDifficultyBlocks;
            this.DefaultDynamicFeeMultiplier = defaultDynamicFeeMultiplier;
            this.MaxTransactionLifetime = maxTransactionLifetime;
            this.MaxBlockFutureTime = maxBlockFutureTime;
            this.InitialCurrencyAtomicUnits = initialCurrencyAtomicUnits;
            this.MaxMosaicAtomicUnits = maxMosaicAtomicUnits;
            this.TotalChainImportance = totalChainImportance;
            this.MinHarvesterBalance = minHarvesterBalance;
            this.MaxHarvesterBalance = maxHarvesterBalance;
            this.MinVoterBalance = minVoterBalance;
            this.MaxVotingKeysPerAccount = maxVotingKeysPerAccount;
            this.MinVotingKeyLifetime = minVotingKeyLifetime;
            this.MaxVotingKeyLifetime = maxVotingKeyLifetime;
            this.HarvestBeneficiaryPercentage = harvestBeneficiaryPercentage;
            this.HarvestNetworkPercentage = harvestNetworkPercentage;
            this.HarvestNetworkFeeSinkAddress = harvestNetworkFeeSinkAddress;
            this.BlockPruneInterval = blockPruneInterval;
            this.MaxTransactionsPerBlock = maxTransactionsPerBlock;
        }

        /// <summary>
        /// Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.
        /// </summary>
        /// <value>Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.</value>
        [DataMember(Name="enableVerifiableState", EmitDefaultValue=false)]
        public bool EnableVerifiableState { get; set; }

        /// <summary>
        /// Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.
        /// </summary>
        /// <value>Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.</value>
        [DataMember(Name="enableVerifiableReceipts", EmitDefaultValue=false)]
        public bool EnableVerifiableReceipts { get; set; }

        /// <summary>
        /// Mosaic id used as primary chain currency.
        /// </summary>
        /// <value>Mosaic id used as primary chain currency.</value>
        [DataMember(Name="currencyMosaicId", EmitDefaultValue=false)]
        public string CurrencyMosaicId { get; set; }

        /// <summary>
        /// Mosaic id used to provide harvesting ability.
        /// </summary>
        /// <value>Mosaic id used to provide harvesting ability.</value>
        [DataMember(Name="harvestingMosaicId", EmitDefaultValue=false)]
        public string HarvestingMosaicId { get; set; }

        /// <summary>
        /// Targeted time between blocks.
        /// </summary>
        /// <value>Targeted time between blocks.</value>
        [DataMember(Name="blockGenerationTargetTime", EmitDefaultValue=false)]
        public string BlockGenerationTargetTime { get; set; }

        /// <summary>
        /// A higher value makes the network more biased.
        /// </summary>
        /// <value>A higher value makes the network more biased.</value>
        [DataMember(Name="blockTimeSmoothingFactor", EmitDefaultValue=false)]
        public string BlockTimeSmoothingFactor { get; set; }

        /// <summary>
        /// Number of blocks between successive finalization attempts.
        /// </summary>
        /// <value>Number of blocks between successive finalization attempts.</value>
        [DataMember(Name="blockFinalizationInterval", EmitDefaultValue=false)]
        public string BlockFinalizationInterval { get; set; }

        /// <summary>
        /// Number of blocks that should be treated as a group for importance purposes.
        /// </summary>
        /// <value>Number of blocks that should be treated as a group for importance purposes.</value>
        [DataMember(Name="importanceGrouping", EmitDefaultValue=false)]
        public string ImportanceGrouping { get; set; }

        /// <summary>
        /// Percentage of importance resulting from fee generation and beneficiary usage.
        /// </summary>
        /// <value>Percentage of importance resulting from fee generation and beneficiary usage.</value>
        [DataMember(Name="importanceActivityPercentage", EmitDefaultValue=false)]
        public string ImportanceActivityPercentage { get; set; }

        /// <summary>
        /// Maximum number of blocks that can be rolled back.
        /// </summary>
        /// <value>Maximum number of blocks that can be rolled back.</value>
        [DataMember(Name="maxRollbackBlocks", EmitDefaultValue=false)]
        public string MaxRollbackBlocks { get; set; }

        /// <summary>
        /// Maximum number of blocks to use in a difficulty calculation.
        /// </summary>
        /// <value>Maximum number of blocks to use in a difficulty calculation.</value>
        [DataMember(Name="maxDifficultyBlocks", EmitDefaultValue=false)]
        public string MaxDifficultyBlocks { get; set; }

        /// <summary>
        /// Default multiplier to use for dynamic fees.
        /// </summary>
        /// <value>Default multiplier to use for dynamic fees.</value>
        [DataMember(Name="defaultDynamicFeeMultiplier", EmitDefaultValue=false)]
        public string DefaultDynamicFeeMultiplier { get; set; }

        /// <summary>
        /// Maximum lifetime a transaction can have before it expires.
        /// </summary>
        /// <value>Maximum lifetime a transaction can have before it expires.</value>
        [DataMember(Name="maxTransactionLifetime", EmitDefaultValue=false)]
        public string MaxTransactionLifetime { get; set; }

        /// <summary>
        /// Maximum future time of a block that can be accepted.
        /// </summary>
        /// <value>Maximum future time of a block that can be accepted.</value>
        [DataMember(Name="maxBlockFutureTime", EmitDefaultValue=false)]
        public string MaxBlockFutureTime { get; set; }

        /// <summary>
        /// Initial currency atomic units available in the network.
        /// </summary>
        /// <value>Initial currency atomic units available in the network.</value>
        [DataMember(Name="initialCurrencyAtomicUnits", EmitDefaultValue=false)]
        public string InitialCurrencyAtomicUnits { get; set; }

        /// <summary>
        /// Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.
        /// </summary>
        /// <value>Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.</value>
        [DataMember(Name="maxMosaicAtomicUnits", EmitDefaultValue=false)]
        public string MaxMosaicAtomicUnits { get; set; }

        /// <summary>
        /// Total whole importance units available in the network.
        /// </summary>
        /// <value>Total whole importance units available in the network.</value>
        [DataMember(Name="totalChainImportance", EmitDefaultValue=false)]
        public string TotalChainImportance { get; set; }

        /// <summary>
        /// Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
        /// </summary>
        /// <value>Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.</value>
        [DataMember(Name="minHarvesterBalance", EmitDefaultValue=false)]
        public string MinHarvesterBalance { get; set; }

        /// <summary>
        /// Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
        /// </summary>
        /// <value>Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.</value>
        [DataMember(Name="maxHarvesterBalance", EmitDefaultValue=false)]
        public string MaxHarvesterBalance { get; set; }

        /// <summary>
        /// Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.
        /// </summary>
        /// <value>Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.</value>
        [DataMember(Name="minVoterBalance", EmitDefaultValue=false)]
        public string MinVoterBalance { get; set; }

        /// <summary>
        /// Maximum number of voting keys that can be registered at once per account.
        /// </summary>
        /// <value>Maximum number of voting keys that can be registered at once per account.</value>
        [DataMember(Name="maxVotingKeysPerAccount", EmitDefaultValue=false)]
        public string MaxVotingKeysPerAccount { get; set; }

        /// <summary>
        /// Minimum number of finalization rounds for which voting key can be registered.
        /// </summary>
        /// <value>Minimum number of finalization rounds for which voting key can be registered.</value>
        [DataMember(Name="minVotingKeyLifetime", EmitDefaultValue=false)]
        public string MinVotingKeyLifetime { get; set; }

        /// <summary>
        /// Maximum number of finalization rounds for which voting key can be registered.
        /// </summary>
        /// <value>Maximum number of finalization rounds for which voting key can be registered.</value>
        [DataMember(Name="maxVotingKeyLifetime", EmitDefaultValue=false)]
        public string MaxVotingKeyLifetime { get; set; }

        /// <summary>
        /// Percentage of the harvested fee that is collected by the beneficiary account.
        /// </summary>
        /// <value>Percentage of the harvested fee that is collected by the beneficiary account.</value>
        [DataMember(Name="harvestBeneficiaryPercentage", EmitDefaultValue=false)]
        public string HarvestBeneficiaryPercentage { get; set; }

        /// <summary>
        /// Percentage of the harvested fee that is collected by the network.
        /// </summary>
        /// <value>Percentage of the harvested fee that is collected by the network.</value>
        [DataMember(Name="harvestNetworkPercentage", EmitDefaultValue=false)]
        public string HarvestNetworkPercentage { get; set; }

        /// <summary>
        /// Address encoded using a 32-character set.
        /// </summary>
        /// <value>Address encoded using a 32-character set.</value>
        [DataMember(Name="harvestNetworkFeeSinkAddress", EmitDefaultValue=false)]
        public string HarvestNetworkFeeSinkAddress { get; set; }

        /// <summary>
        /// Number of blocks between cache pruning.
        /// </summary>
        /// <value>Number of blocks between cache pruning.</value>
        [DataMember(Name="blockPruneInterval", EmitDefaultValue=false)]
        public string BlockPruneInterval { get; set; }

        /// <summary>
        /// Maximum number of transactions per block.
        /// </summary>
        /// <value>Maximum number of transactions per block.</value>
        [DataMember(Name="maxTransactionsPerBlock", EmitDefaultValue=false)]
        public string MaxTransactionsPerBlock { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ChainPropertiesDTO {\n");
            sb.Append("  EnableVerifiableState: ").Append(EnableVerifiableState).Append("\n");
            sb.Append("  EnableVerifiableReceipts: ").Append(EnableVerifiableReceipts).Append("\n");
            sb.Append("  CurrencyMosaicId: ").Append(CurrencyMosaicId).Append("\n");
            sb.Append("  HarvestingMosaicId: ").Append(HarvestingMosaicId).Append("\n");
            sb.Append("  BlockGenerationTargetTime: ").Append(BlockGenerationTargetTime).Append("\n");
            sb.Append("  BlockTimeSmoothingFactor: ").Append(BlockTimeSmoothingFactor).Append("\n");
            sb.Append("  BlockFinalizationInterval: ").Append(BlockFinalizationInterval).Append("\n");
            sb.Append("  ImportanceGrouping: ").Append(ImportanceGrouping).Append("\n");
            sb.Append("  ImportanceActivityPercentage: ").Append(ImportanceActivityPercentage).Append("\n");
            sb.Append("  MaxRollbackBlocks: ").Append(MaxRollbackBlocks).Append("\n");
            sb.Append("  MaxDifficultyBlocks: ").Append(MaxDifficultyBlocks).Append("\n");
            sb.Append("  DefaultDynamicFeeMultiplier: ").Append(DefaultDynamicFeeMultiplier).Append("\n");
            sb.Append("  MaxTransactionLifetime: ").Append(MaxTransactionLifetime).Append("\n");
            sb.Append("  MaxBlockFutureTime: ").Append(MaxBlockFutureTime).Append("\n");
            sb.Append("  InitialCurrencyAtomicUnits: ").Append(InitialCurrencyAtomicUnits).Append("\n");
            sb.Append("  MaxMosaicAtomicUnits: ").Append(MaxMosaicAtomicUnits).Append("\n");
            sb.Append("  TotalChainImportance: ").Append(TotalChainImportance).Append("\n");
            sb.Append("  MinHarvesterBalance: ").Append(MinHarvesterBalance).Append("\n");
            sb.Append("  MaxHarvesterBalance: ").Append(MaxHarvesterBalance).Append("\n");
            sb.Append("  MinVoterBalance: ").Append(MinVoterBalance).Append("\n");
            sb.Append("  MaxVotingKeysPerAccount: ").Append(MaxVotingKeysPerAccount).Append("\n");
            sb.Append("  MinVotingKeyLifetime: ").Append(MinVotingKeyLifetime).Append("\n");
            sb.Append("  MaxVotingKeyLifetime: ").Append(MaxVotingKeyLifetime).Append("\n");
            sb.Append("  HarvestBeneficiaryPercentage: ").Append(HarvestBeneficiaryPercentage).Append("\n");
            sb.Append("  HarvestNetworkPercentage: ").Append(HarvestNetworkPercentage).Append("\n");
            sb.Append("  HarvestNetworkFeeSinkAddress: ").Append(HarvestNetworkFeeSinkAddress).Append("\n");
            sb.Append("  BlockPruneInterval: ").Append(BlockPruneInterval).Append("\n");
            sb.Append("  MaxTransactionsPerBlock: ").Append(MaxTransactionsPerBlock).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ChainPropertiesDTO);
        }

        /// <summary>
        /// Returns true if ChainPropertiesDTO instances are equal
        /// </summary>
        /// <param name="input">Instance of ChainPropertiesDTO to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ChainPropertiesDTO input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.EnableVerifiableState == input.EnableVerifiableState ||
                    (this.EnableVerifiableState != null &&
                    this.EnableVerifiableState.Equals(input.EnableVerifiableState))
                ) && 
                (
                    this.EnableVerifiableReceipts == input.EnableVerifiableReceipts ||
                    (this.EnableVerifiableReceipts != null &&
                    this.EnableVerifiableReceipts.Equals(input.EnableVerifiableReceipts))
                ) && 
                (
                    this.CurrencyMosaicId == input.CurrencyMosaicId ||
                    (this.CurrencyMosaicId != null &&
                    this.CurrencyMosaicId.Equals(input.CurrencyMosaicId))
                ) && 
                (
                    this.HarvestingMosaicId == input.HarvestingMosaicId ||
                    (this.HarvestingMosaicId != null &&
                    this.HarvestingMosaicId.Equals(input.HarvestingMosaicId))
                ) && 
                (
                    this.BlockGenerationTargetTime == input.BlockGenerationTargetTime ||
                    (this.BlockGenerationTargetTime != null &&
                    this.BlockGenerationTargetTime.Equals(input.BlockGenerationTargetTime))
                ) && 
                (
                    this.BlockTimeSmoothingFactor == input.BlockTimeSmoothingFactor ||
                    (this.BlockTimeSmoothingFactor != null &&
                    this.BlockTimeSmoothingFactor.Equals(input.BlockTimeSmoothingFactor))
                ) && 
                (
                    this.BlockFinalizationInterval == input.BlockFinalizationInterval ||
                    (this.BlockFinalizationInterval != null &&
                    this.BlockFinalizationInterval.Equals(input.BlockFinalizationInterval))
                ) && 
                (
                    this.ImportanceGrouping == input.ImportanceGrouping ||
                    (this.ImportanceGrouping != null &&
                    this.ImportanceGrouping.Equals(input.ImportanceGrouping))
                ) && 
                (
                    this.ImportanceActivityPercentage == input.ImportanceActivityPercentage ||
                    (this.ImportanceActivityPercentage != null &&
                    this.ImportanceActivityPercentage.Equals(input.ImportanceActivityPercentage))
                ) && 
                (
                    this.MaxRollbackBlocks == input.MaxRollbackBlocks ||
                    (this.MaxRollbackBlocks != null &&
                    this.MaxRollbackBlocks.Equals(input.MaxRollbackBlocks))
                ) && 
                (
                    this.MaxDifficultyBlocks == input.MaxDifficultyBlocks ||
                    (this.MaxDifficultyBlocks != null &&
                    this.MaxDifficultyBlocks.Equals(input.MaxDifficultyBlocks))
                ) && 
                (
                    this.DefaultDynamicFeeMultiplier == input.DefaultDynamicFeeMultiplier ||
                    (this.DefaultDynamicFeeMultiplier != null &&
                    this.DefaultDynamicFeeMultiplier.Equals(input.DefaultDynamicFeeMultiplier))
                ) && 
                (
                    this.MaxTransactionLifetime == input.MaxTransactionLifetime ||
                    (this.MaxTransactionLifetime != null &&
                    this.MaxTransactionLifetime.Equals(input.MaxTransactionLifetime))
                ) && 
                (
                    this.MaxBlockFutureTime == input.MaxBlockFutureTime ||
                    (this.MaxBlockFutureTime != null &&
                    this.MaxBlockFutureTime.Equals(input.MaxBlockFutureTime))
                ) && 
                (
                    this.InitialCurrencyAtomicUnits == input.InitialCurrencyAtomicUnits ||
                    (this.InitialCurrencyAtomicUnits != null &&
                    this.InitialCurrencyAtomicUnits.Equals(input.InitialCurrencyAtomicUnits))
                ) && 
                (
                    this.MaxMosaicAtomicUnits == input.MaxMosaicAtomicUnits ||
                    (this.MaxMosaicAtomicUnits != null &&
                    this.MaxMosaicAtomicUnits.Equals(input.MaxMosaicAtomicUnits))
                ) && 
                (
                    this.TotalChainImportance == input.TotalChainImportance ||
                    (this.TotalChainImportance != null &&
                    this.TotalChainImportance.Equals(input.TotalChainImportance))
                ) && 
                (
                    this.MinHarvesterBalance == input.MinHarvesterBalance ||
                    (this.MinHarvesterBalance != null &&
                    this.MinHarvesterBalance.Equals(input.MinHarvesterBalance))
                ) && 
                (
                    this.MaxHarvesterBalance == input.MaxHarvesterBalance ||
                    (this.MaxHarvesterBalance != null &&
                    this.MaxHarvesterBalance.Equals(input.MaxHarvesterBalance))
                ) && 
                (
                    this.MinVoterBalance == input.MinVoterBalance ||
                    (this.MinVoterBalance != null &&
                    this.MinVoterBalance.Equals(input.MinVoterBalance))
                ) && 
                (
                    this.MaxVotingKeysPerAccount == input.MaxVotingKeysPerAccount ||
                    (this.MaxVotingKeysPerAccount != null &&
                    this.MaxVotingKeysPerAccount.Equals(input.MaxVotingKeysPerAccount))
                ) && 
                (
                    this.MinVotingKeyLifetime == input.MinVotingKeyLifetime ||
                    (this.MinVotingKeyLifetime != null &&
                    this.MinVotingKeyLifetime.Equals(input.MinVotingKeyLifetime))
                ) && 
                (
                    this.MaxVotingKeyLifetime == input.MaxVotingKeyLifetime ||
                    (this.MaxVotingKeyLifetime != null &&
                    this.MaxVotingKeyLifetime.Equals(input.MaxVotingKeyLifetime))
                ) && 
                (
                    this.HarvestBeneficiaryPercentage == input.HarvestBeneficiaryPercentage ||
                    (this.HarvestBeneficiaryPercentage != null &&
                    this.HarvestBeneficiaryPercentage.Equals(input.HarvestBeneficiaryPercentage))
                ) && 
                (
                    this.HarvestNetworkPercentage == input.HarvestNetworkPercentage ||
                    (this.HarvestNetworkPercentage != null &&
                    this.HarvestNetworkPercentage.Equals(input.HarvestNetworkPercentage))
                ) && 
                (
                    this.HarvestNetworkFeeSinkAddress == input.HarvestNetworkFeeSinkAddress ||
                    (this.HarvestNetworkFeeSinkAddress != null &&
                    this.HarvestNetworkFeeSinkAddress.Equals(input.HarvestNetworkFeeSinkAddress))
                ) && 
                (
                    this.BlockPruneInterval == input.BlockPruneInterval ||
                    (this.BlockPruneInterval != null &&
                    this.BlockPruneInterval.Equals(input.BlockPruneInterval))
                ) && 
                (
                    this.MaxTransactionsPerBlock == input.MaxTransactionsPerBlock ||
                    (this.MaxTransactionsPerBlock != null &&
                    this.MaxTransactionsPerBlock.Equals(input.MaxTransactionsPerBlock))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EnableVerifiableState != null)
                    hashCode = hashCode * 59 + this.EnableVerifiableState.GetHashCode();
                if (this.EnableVerifiableReceipts != null)
                    hashCode = hashCode * 59 + this.EnableVerifiableReceipts.GetHashCode();
                if (this.CurrencyMosaicId != null)
                    hashCode = hashCode * 59 + this.CurrencyMosaicId.GetHashCode();
                if (this.HarvestingMosaicId != null)
                    hashCode = hashCode * 59 + this.HarvestingMosaicId.GetHashCode();
                if (this.BlockGenerationTargetTime != null)
                    hashCode = hashCode * 59 + this.BlockGenerationTargetTime.GetHashCode();
                if (this.BlockTimeSmoothingFactor != null)
                    hashCode = hashCode * 59 + this.BlockTimeSmoothingFactor.GetHashCode();
                if (this.BlockFinalizationInterval != null)
                    hashCode = hashCode * 59 + this.BlockFinalizationInterval.GetHashCode();
                if (this.ImportanceGrouping != null)
                    hashCode = hashCode * 59 + this.ImportanceGrouping.GetHashCode();
                if (this.ImportanceActivityPercentage != null)
                    hashCode = hashCode * 59 + this.ImportanceActivityPercentage.GetHashCode();
                if (this.MaxRollbackBlocks != null)
                    hashCode = hashCode * 59 + this.MaxRollbackBlocks.GetHashCode();
                if (this.MaxDifficultyBlocks != null)
                    hashCode = hashCode * 59 + this.MaxDifficultyBlocks.GetHashCode();
                if (this.DefaultDynamicFeeMultiplier != null)
                    hashCode = hashCode * 59 + this.DefaultDynamicFeeMultiplier.GetHashCode();
                if (this.MaxTransactionLifetime != null)
                    hashCode = hashCode * 59 + this.MaxTransactionLifetime.GetHashCode();
                if (this.MaxBlockFutureTime != null)
                    hashCode = hashCode * 59 + this.MaxBlockFutureTime.GetHashCode();
                if (this.InitialCurrencyAtomicUnits != null)
                    hashCode = hashCode * 59 + this.InitialCurrencyAtomicUnits.GetHashCode();
                if (this.MaxMosaicAtomicUnits != null)
                    hashCode = hashCode * 59 + this.MaxMosaicAtomicUnits.GetHashCode();
                if (this.TotalChainImportance != null)
                    hashCode = hashCode * 59 + this.TotalChainImportance.GetHashCode();
                if (this.MinHarvesterBalance != null)
                    hashCode = hashCode * 59 + this.MinHarvesterBalance.GetHashCode();
                if (this.MaxHarvesterBalance != null)
                    hashCode = hashCode * 59 + this.MaxHarvesterBalance.GetHashCode();
                if (this.MinVoterBalance != null)
                    hashCode = hashCode * 59 + this.MinVoterBalance.GetHashCode();
                if (this.MaxVotingKeysPerAccount != null)
                    hashCode = hashCode * 59 + this.MaxVotingKeysPerAccount.GetHashCode();
                if (this.MinVotingKeyLifetime != null)
                    hashCode = hashCode * 59 + this.MinVotingKeyLifetime.GetHashCode();
                if (this.MaxVotingKeyLifetime != null)
                    hashCode = hashCode * 59 + this.MaxVotingKeyLifetime.GetHashCode();
                if (this.HarvestBeneficiaryPercentage != null)
                    hashCode = hashCode * 59 + this.HarvestBeneficiaryPercentage.GetHashCode();
                if (this.HarvestNetworkPercentage != null)
                    hashCode = hashCode * 59 + this.HarvestNetworkPercentage.GetHashCode();
                if (this.HarvestNetworkFeeSinkAddress != null)
                    hashCode = hashCode * 59 + this.HarvestNetworkFeeSinkAddress.GetHashCode();
                if (this.BlockPruneInterval != null)
                    hashCode = hashCode * 59 + this.BlockPruneInterval.GetHashCode();
                if (this.MaxTransactionsPerBlock != null)
                    hashCode = hashCode * 59 + this.MaxTransactionsPerBlock.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
