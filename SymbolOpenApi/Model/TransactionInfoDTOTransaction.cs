/*
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = SymbolOpenApi.Client.OpenAPIDateConverter;

namespace SymbolOpenApi.Model
{
    /// <summary>
    /// TransactionInfoDTOTransaction
    /// </summary>
    [DataContract]
    public partial class TransactionInfoDTOTransaction :  IEquatable<TransactionInfoDTOTransaction>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Network
        /// </summary>
        [DataMember(Name="network", EmitDefaultValue=true)]
        public NetworkTypeEnum Network { get; set; }
        /// <summary>
        /// Gets or Sets LinkAction
        /// </summary>
        [DataMember(Name="linkAction", EmitDefaultValue=true)]
        public LinkActionEnum LinkAction { get; set; }
        /// <summary>
        /// Gets or Sets HashAlgorithm
        /// </summary>
        [DataMember(Name="hashAlgorithm", EmitDefaultValue=true)]
        public LockHashAlgorithmEnum HashAlgorithm { get; set; }
        /// <summary>
        /// Gets or Sets Action
        /// </summary>
        [DataMember(Name="action", EmitDefaultValue=true)]
        public MosaicSupplyChangeActionEnum Action { get; set; }
        /// <summary>
        /// Gets or Sets RegistrationType
        /// </summary>
        [DataMember(Name="registrationType", EmitDefaultValue=true)]
        public NamespaceRegistrationTypeEnum RegistrationType { get; set; }
        /// <summary>
        /// Gets or Sets AliasAction
        /// </summary>
        [DataMember(Name="aliasAction", EmitDefaultValue=true)]
        public AliasActionEnum AliasAction { get; set; }
        /// <summary>
        /// Gets or Sets RestrictionFlags
        /// </summary>
        [DataMember(Name="restrictionFlags", EmitDefaultValue=true)]
        public AccountRestrictionFlagsEnum RestrictionFlags { get; set; }
        /// <summary>
        /// Gets or Sets PreviousRestrictionType
        /// </summary>
        [DataMember(Name="previousRestrictionType", EmitDefaultValue=true)]
        public MosaicRestrictionTypeEnum PreviousRestrictionType { get; set; }
        /// <summary>
        /// Gets or Sets NewRestrictionType
        /// </summary>
        [DataMember(Name="newRestrictionType", EmitDefaultValue=true)]
        public MosaicRestrictionTypeEnum NewRestrictionType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionInfoDTOTransaction" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TransactionInfoDTOTransaction() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionInfoDTOTransaction" /> class.
        /// </summary>
        /// <param name="size">A number that allows uint 32 values. (required).</param>
        /// <param name="signature">Entity&#39;s signature generated by the signer. (required).</param>
        /// <param name="signerPublicKey">Public key. (required).</param>
        /// <param name="version">Entity version. (required).</param>
        /// <param name="network">network (required).</param>
        /// <param name="type">type (required).</param>
        /// <param name="maxFee">Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative). (required).</param>
        /// <param name="deadline">Duration expressed in number of blocks. (required).</param>
        /// <param name="linkedPublicKey">32 bytes voting public key. (required).</param>
        /// <param name="linkAction">linkAction (required).</param>
        /// <param name="startEpoch">Finalization Epoch (required).</param>
        /// <param name="endEpoch">Finalization Epoch (required).</param>
        /// <param name="transactionsHash">transactionsHash (required).</param>
        /// <param name="cosignatures">Array of transaction cosignatures. (required).</param>
        /// <param name="transactions">Array of transactions initiated by different accounts. (required).</param>
        /// <param name="mosaicId">Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  (required).</param>
        /// <param name="amount">Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative). (required).</param>
        /// <param name="duration">Duration expressed in number of blocks. (required).</param>
        /// <param name="hash">hash (required).</param>
        /// <param name="recipientAddress">Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  (required).</param>
        /// <param name="secret">secret (required).</param>
        /// <param name="hashAlgorithm">hashAlgorithm (required).</param>
        /// <param name="proof">Original random set of bytes. (required).</param>
        /// <param name="targetAddress">Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  (required).</param>
        /// <param name="scopedMetadataKey">Metadata key scoped to source, target and type expressed. (required).</param>
        /// <param name="valueSizeDelta">Change in value size in bytes. (required).</param>
        /// <param name="valueSize">A number that allows uint 32 values. (required).</param>
        /// <param name="value">Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value). (required).</param>
        /// <param name="targetMosaicId">Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  (required).</param>
        /// <param name="targetNamespaceId">Namespace identifier..</param>
        /// <param name="id">Namespace identifier. (required).</param>
        /// <param name="nonce">A number that allows uint 32 values. (required).</param>
        /// <param name="flags">- 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user.  (required).</param>
        /// <param name="divisibility">Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6.  (required).</param>
        /// <param name="delta">Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative). (required).</param>
        /// <param name="action">action (required).</param>
        /// <param name="sourceAddress">Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  (required).</param>
        /// <param name="parentId">Namespace identifier..</param>
        /// <param name="registrationType">registrationType (required).</param>
        /// <param name="name">Namespace name. (required).</param>
        /// <param name="namespaceId">Namespace identifier. (required).</param>
        /// <param name="address">Address encoded using a 32-character set. (required).</param>
        /// <param name="aliasAction">aliasAction (required).</param>
        /// <param name="minRemovalDelta">Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.  (required).</param>
        /// <param name="minApprovalDelta">Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.  (required).</param>
        /// <param name="addressAdditions">Array of cosignatory accounts to add. (required).</param>
        /// <param name="addressDeletions">Array of cosignatory accounts to delete. (required).</param>
        /// <param name="restrictionFlags">restrictionFlags (required).</param>
        /// <param name="restrictionAdditions">Account restriction additions. (required).</param>
        /// <param name="restrictionDeletions">Account restriction deletions. (required).</param>
        /// <param name="referenceMosaicId">Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  (required).</param>
        /// <param name="restrictionKey">Restriction key. (required).</param>
        /// <param name="previousRestrictionValue">Restriction value. (required).</param>
        /// <param name="newRestrictionValue">Restriction value. (required).</param>
        /// <param name="previousRestrictionType">previousRestrictionType (required).</param>
        /// <param name="newRestrictionType">newRestrictionType (required).</param>
        /// <param name="mosaics">Array of mosaics sent to the recipient.  (required).</param>
        /// <param name="message">Transfer transaction message.</param>
        public TransactionInfoDTOTransaction(long size = default(long), string signature = default(string), string signerPublicKey = default(string), int version = default(int), NetworkTypeEnum network = default(NetworkTypeEnum), int type = default(int), string maxFee = default(string), string deadline = default(string), string linkedPublicKey = default(string), LinkActionEnum linkAction = default(LinkActionEnum), long startEpoch = default(long), long endEpoch = default(long), string transactionsHash = default(string), List<CosignatureDTO> cosignatures = default(List<CosignatureDTO>), List<EmbeddedTransactionInfoDTO> transactions = default(List<EmbeddedTransactionInfoDTO>), string mosaicId = default(string), string amount = default(string), string duration = default(string), string hash = default(string), string recipientAddress = default(string), string secret = default(string), LockHashAlgorithmEnum hashAlgorithm = default(LockHashAlgorithmEnum), string proof = default(string), string targetAddress = default(string), string scopedMetadataKey = default(string), int valueSizeDelta = default(int), long valueSize = default(long), string value = default(string), string targetMosaicId = default(string), string targetNamespaceId = default(string), string id = default(string), long nonce = default(long), int flags = default(int), int divisibility = default(int), string delta = default(string), MosaicSupplyChangeActionEnum action = default(MosaicSupplyChangeActionEnum), string sourceAddress = default(string), string parentId = default(string), NamespaceRegistrationTypeEnum registrationType = default(NamespaceRegistrationTypeEnum), string name = default(string), string namespaceId = default(string), string address = default(string), AliasActionEnum aliasAction = default(AliasActionEnum), int minRemovalDelta = default(int), int minApprovalDelta = default(int), List<string> addressAdditions = default(List<string>), List<string> addressDeletions = default(List<string>), AccountRestrictionFlagsEnum restrictionFlags = default(AccountRestrictionFlagsEnum), List<TransactionTypeEnum> restrictionAdditions = default(List<TransactionTypeEnum>), List<TransactionTypeEnum> restrictionDeletions = default(List<TransactionTypeEnum>), string referenceMosaicId = default(string), string restrictionKey = default(string), string previousRestrictionValue = default(string), string newRestrictionValue = default(string), MosaicRestrictionTypeEnum previousRestrictionType = default(MosaicRestrictionTypeEnum), MosaicRestrictionTypeEnum newRestrictionType = default(MosaicRestrictionTypeEnum), List<UnresolvedMosaic> mosaics = default(List<UnresolvedMosaic>), string message = default(string))
        {
            // to ensure "size" is required (not null)
            if (size == null)
            {
                throw new InvalidDataException("size is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Size = size;
            }

            // to ensure "signature" is required (not null)
            if (signature == null)
            {
                throw new InvalidDataException("signature is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Signature = signature;
            }

            // to ensure "signerPublicKey" is required (not null)
            if (signerPublicKey == null)
            {
                throw new InvalidDataException("signerPublicKey is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.SignerPublicKey = signerPublicKey;
            }

            // to ensure "version" is required (not null)
            if (version == null)
            {
                throw new InvalidDataException("version is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this._Version = version;
            }

            // to ensure "network" is required (not null)
            if (network == null)
            {
                throw new InvalidDataException("network is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Network = network;
            }

            // to ensure "type" is required (not null)
            if (type == null)
            {
                throw new InvalidDataException("type is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Type = type;
            }

            // to ensure "maxFee" is required (not null)
            if (maxFee == null)
            {
                throw new InvalidDataException("maxFee is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.MaxFee = maxFee;
            }

            // to ensure "deadline" is required (not null)
            if (deadline == null)
            {
                throw new InvalidDataException("deadline is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Deadline = deadline;
            }

            // to ensure "linkedPublicKey" is required (not null)
            if (linkedPublicKey == null)
            {
                throw new InvalidDataException("linkedPublicKey is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.LinkedPublicKey = linkedPublicKey;
            }

            // to ensure "linkAction" is required (not null)
            if (linkAction == null)
            {
                throw new InvalidDataException("linkAction is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.LinkAction = linkAction;
            }

            // to ensure "startEpoch" is required (not null)
            if (startEpoch == null)
            {
                throw new InvalidDataException("startEpoch is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.StartEpoch = startEpoch;
            }

            // to ensure "endEpoch" is required (not null)
            if (endEpoch == null)
            {
                throw new InvalidDataException("endEpoch is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.EndEpoch = endEpoch;
            }

            // to ensure "transactionsHash" is required (not null)
            if (transactionsHash == null)
            {
                throw new InvalidDataException("transactionsHash is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.TransactionsHash = transactionsHash;
            }

            // to ensure "cosignatures" is required (not null)
            if (cosignatures == null)
            {
                throw new InvalidDataException("cosignatures is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Cosignatures = cosignatures;
            }

            // to ensure "transactions" is required (not null)
            if (transactions == null)
            {
                throw new InvalidDataException("transactions is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Transactions = transactions;
            }

            // to ensure "mosaicId" is required (not null)
            if (mosaicId == null)
            {
                throw new InvalidDataException("mosaicId is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.MosaicId = mosaicId;
            }

            // to ensure "amount" is required (not null)
            if (amount == null)
            {
                throw new InvalidDataException("amount is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Amount = amount;
            }

            // to ensure "duration" is required (not null)
            if (duration == null)
            {
                throw new InvalidDataException("duration is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Duration = duration;
            }

            // to ensure "hash" is required (not null)
            if (hash == null)
            {
                throw new InvalidDataException("hash is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Hash = hash;
            }

            // to ensure "recipientAddress" is required (not null)
            if (recipientAddress == null)
            {
                throw new InvalidDataException("recipientAddress is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RecipientAddress = recipientAddress;
            }

            // to ensure "secret" is required (not null)
            if (secret == null)
            {
                throw new InvalidDataException("secret is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Secret = secret;
            }

            // to ensure "hashAlgorithm" is required (not null)
            if (hashAlgorithm == null)
            {
                throw new InvalidDataException("hashAlgorithm is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.HashAlgorithm = hashAlgorithm;
            }

            // to ensure "proof" is required (not null)
            if (proof == null)
            {
                throw new InvalidDataException("proof is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Proof = proof;
            }

            // to ensure "targetAddress" is required (not null)
            if (targetAddress == null)
            {
                throw new InvalidDataException("targetAddress is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.TargetAddress = targetAddress;
            }

            // to ensure "scopedMetadataKey" is required (not null)
            if (scopedMetadataKey == null)
            {
                throw new InvalidDataException("scopedMetadataKey is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.ScopedMetadataKey = scopedMetadataKey;
            }

            // to ensure "valueSizeDelta" is required (not null)
            if (valueSizeDelta == null)
            {
                throw new InvalidDataException("valueSizeDelta is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.ValueSizeDelta = valueSizeDelta;
            }

            // to ensure "valueSize" is required (not null)
            if (valueSize == null)
            {
                throw new InvalidDataException("valueSize is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.ValueSize = valueSize;
            }

            // to ensure "value" is required (not null)
            if (value == null)
            {
                throw new InvalidDataException("value is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Value = value;
            }

            // to ensure "targetMosaicId" is required (not null)
            if (targetMosaicId == null)
            {
                throw new InvalidDataException("targetMosaicId is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.TargetMosaicId = targetMosaicId;
            }

            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new InvalidDataException("id is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Id = id;
            }

            // to ensure "nonce" is required (not null)
            if (nonce == null)
            {
                throw new InvalidDataException("nonce is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Nonce = nonce;
            }

            // to ensure "flags" is required (not null)
            if (flags == null)
            {
                throw new InvalidDataException("flags is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Flags = flags;
            }

            // to ensure "divisibility" is required (not null)
            if (divisibility == null)
            {
                throw new InvalidDataException("divisibility is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Divisibility = divisibility;
            }

            // to ensure "delta" is required (not null)
            if (delta == null)
            {
                throw new InvalidDataException("delta is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Delta = delta;
            }

            // to ensure "action" is required (not null)
            if (action == null)
            {
                throw new InvalidDataException("action is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Action = action;
            }

            // to ensure "sourceAddress" is required (not null)
            if (sourceAddress == null)
            {
                throw new InvalidDataException("sourceAddress is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.SourceAddress = sourceAddress;
            }

            // to ensure "registrationType" is required (not null)
            if (registrationType == null)
            {
                throw new InvalidDataException("registrationType is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RegistrationType = registrationType;
            }

            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Name = name;
            }

            // to ensure "namespaceId" is required (not null)
            if (namespaceId == null)
            {
                throw new InvalidDataException("namespaceId is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.NamespaceId = namespaceId;
            }

            // to ensure "address" is required (not null)
            if (address == null)
            {
                throw new InvalidDataException("address is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Address = address;
            }

            // to ensure "aliasAction" is required (not null)
            if (aliasAction == null)
            {
                throw new InvalidDataException("aliasAction is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.AliasAction = aliasAction;
            }

            // to ensure "minRemovalDelta" is required (not null)
            if (minRemovalDelta == null)
            {
                throw new InvalidDataException("minRemovalDelta is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.MinRemovalDelta = minRemovalDelta;
            }

            // to ensure "minApprovalDelta" is required (not null)
            if (minApprovalDelta == null)
            {
                throw new InvalidDataException("minApprovalDelta is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.MinApprovalDelta = minApprovalDelta;
            }

            // to ensure "addressAdditions" is required (not null)
            if (addressAdditions == null)
            {
                throw new InvalidDataException("addressAdditions is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.AddressAdditions = addressAdditions;
            }

            // to ensure "addressDeletions" is required (not null)
            if (addressDeletions == null)
            {
                throw new InvalidDataException("addressDeletions is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.AddressDeletions = addressDeletions;
            }

            // to ensure "restrictionFlags" is required (not null)
            if (restrictionFlags == null)
            {
                throw new InvalidDataException("restrictionFlags is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RestrictionFlags = restrictionFlags;
            }

            // to ensure "restrictionAdditions" is required (not null)
            if (restrictionAdditions == null)
            {
                throw new InvalidDataException("restrictionAdditions is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RestrictionAdditions = restrictionAdditions;
            }

            // to ensure "restrictionDeletions" is required (not null)
            if (restrictionDeletions == null)
            {
                throw new InvalidDataException("restrictionDeletions is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RestrictionDeletions = restrictionDeletions;
            }

            // to ensure "referenceMosaicId" is required (not null)
            if (referenceMosaicId == null)
            {
                throw new InvalidDataException("referenceMosaicId is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.ReferenceMosaicId = referenceMosaicId;
            }

            // to ensure "restrictionKey" is required (not null)
            if (restrictionKey == null)
            {
                throw new InvalidDataException("restrictionKey is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.RestrictionKey = restrictionKey;
            }

            // to ensure "previousRestrictionValue" is required (not null)
            if (previousRestrictionValue == null)
            {
                throw new InvalidDataException("previousRestrictionValue is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.PreviousRestrictionValue = previousRestrictionValue;
            }

            // to ensure "newRestrictionValue" is required (not null)
            if (newRestrictionValue == null)
            {
                throw new InvalidDataException("newRestrictionValue is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.NewRestrictionValue = newRestrictionValue;
            }

            // to ensure "previousRestrictionType" is required (not null)
            if (previousRestrictionType == null)
            {
                throw new InvalidDataException("previousRestrictionType is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.PreviousRestrictionType = previousRestrictionType;
            }

            // to ensure "newRestrictionType" is required (not null)
            if (newRestrictionType == null)
            {
                throw new InvalidDataException("newRestrictionType is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.NewRestrictionType = newRestrictionType;
            }

            // to ensure "mosaics" is required (not null)
            if (mosaics == null)
            {
                throw new InvalidDataException("mosaics is a required property for TransactionInfoDTOTransaction and cannot be null");
            }
            else
            {
                this.Mosaics = mosaics;
            }

            this.TargetNamespaceId = targetNamespaceId;
            this.ParentId = parentId;
            this.Message = message;
        }

        /// <summary>
        /// A number that allows uint 32 values.
        /// </summary>
        /// <value>A number that allows uint 32 values.</value>
        [DataMember(Name="size", EmitDefaultValue=true)]
        public long Size { get; set; }

        /// <summary>
        /// Entity&#39;s signature generated by the signer.
        /// </summary>
        /// <value>Entity&#39;s signature generated by the signer.</value>
        [DataMember(Name="signature", EmitDefaultValue=true)]
        public string Signature { get; set; }

        /// <summary>
        /// Public key.
        /// </summary>
        /// <value>Public key.</value>
        [DataMember(Name="signerPublicKey", EmitDefaultValue=true)]
        public string SignerPublicKey { get; set; }

        /// <summary>
        /// Entity version.
        /// </summary>
        /// <value>Entity version.</value>
        [DataMember(Name="version", EmitDefaultValue=true)]
        public int _Version { get; set; }


        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name="type", EmitDefaultValue=true)]
        public int Type { get; set; }

        /// <summary>
        /// Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
        /// </summary>
        /// <value>Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).</value>
        [DataMember(Name="maxFee", EmitDefaultValue=true)]
        public string MaxFee { get; set; }

        /// <summary>
        /// Duration expressed in number of blocks.
        /// </summary>
        /// <value>Duration expressed in number of blocks.</value>
        [DataMember(Name="deadline", EmitDefaultValue=true)]
        public string Deadline { get; set; }

        /// <summary>
        /// 32 bytes voting public key.
        /// </summary>
        /// <value>32 bytes voting public key.</value>
        [DataMember(Name="linkedPublicKey", EmitDefaultValue=true)]
        public string LinkedPublicKey { get; set; }


        /// <summary>
        /// Finalization Epoch
        /// </summary>
        /// <value>Finalization Epoch</value>
        [DataMember(Name="startEpoch", EmitDefaultValue=true)]
        public long StartEpoch { get; set; }

        /// <summary>
        /// Finalization Epoch
        /// </summary>
        /// <value>Finalization Epoch</value>
        [DataMember(Name="endEpoch", EmitDefaultValue=true)]
        public long EndEpoch { get; set; }

        /// <summary>
        /// Gets or Sets TransactionsHash
        /// </summary>
        [DataMember(Name="transactionsHash", EmitDefaultValue=true)]
        public string TransactionsHash { get; set; }

        /// <summary>
        /// Array of transaction cosignatures.
        /// </summary>
        /// <value>Array of transaction cosignatures.</value>
        [DataMember(Name="cosignatures", EmitDefaultValue=true)]
        public List<CosignatureDTO> Cosignatures { get; set; }

        /// <summary>
        /// Array of transactions initiated by different accounts.
        /// </summary>
        /// <value>Array of transactions initiated by different accounts.</value>
        [DataMember(Name="transactions", EmitDefaultValue=true)]
        public List<EmbeddedTransactionInfoDTO> Transactions { get; set; }

        /// <summary>
        /// Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
        /// </summary>
        /// <value>Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. </value>
        [DataMember(Name="mosaicId", EmitDefaultValue=true)]
        public string MosaicId { get; set; }

        /// <summary>
        /// Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
        /// </summary>
        /// <value>Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).</value>
        [DataMember(Name="amount", EmitDefaultValue=true)]
        public string Amount { get; set; }

        /// <summary>
        /// Duration expressed in number of blocks.
        /// </summary>
        /// <value>Duration expressed in number of blocks.</value>
        [DataMember(Name="duration", EmitDefaultValue=true)]
        public string Duration { get; set; }

        /// <summary>
        /// Gets or Sets Hash
        /// </summary>
        [DataMember(Name="hash", EmitDefaultValue=true)]
        public string Hash { get; set; }

        /// <summary>
        /// Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
        /// </summary>
        /// <value>Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA </value>
        [DataMember(Name="recipientAddress", EmitDefaultValue=true)]
        public string RecipientAddress { get; set; }

        /// <summary>
        /// Gets or Sets Secret
        /// </summary>
        [DataMember(Name="secret", EmitDefaultValue=true)]
        public string Secret { get; set; }


        /// <summary>
        /// Original random set of bytes.
        /// </summary>
        /// <value>Original random set of bytes.</value>
        [DataMember(Name="proof", EmitDefaultValue=true)]
        public string Proof { get; set; }

        /// <summary>
        /// Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
        /// </summary>
        /// <value>Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA </value>
        [DataMember(Name="targetAddress", EmitDefaultValue=true)]
        public string TargetAddress { get; set; }

        /// <summary>
        /// Metadata key scoped to source, target and type expressed.
        /// </summary>
        /// <value>Metadata key scoped to source, target and type expressed.</value>
        [DataMember(Name="scopedMetadataKey", EmitDefaultValue=true)]
        public string ScopedMetadataKey { get; set; }

        /// <summary>
        /// Change in value size in bytes.
        /// </summary>
        /// <value>Change in value size in bytes.</value>
        [DataMember(Name="valueSizeDelta", EmitDefaultValue=true)]
        public int ValueSizeDelta { get; set; }

        /// <summary>
        /// A number that allows uint 32 values.
        /// </summary>
        /// <value>A number that allows uint 32 values.</value>
        [DataMember(Name="valueSize", EmitDefaultValue=true)]
        public long ValueSize { get; set; }

        /// <summary>
        /// Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
        /// </summary>
        /// <value>Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).</value>
        [DataMember(Name="value", EmitDefaultValue=true)]
        public string Value { get; set; }

        /// <summary>
        /// Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
        /// </summary>
        /// <value>Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. </value>
        [DataMember(Name="targetMosaicId", EmitDefaultValue=true)]
        public string TargetMosaicId { get; set; }

        /// <summary>
        /// Namespace identifier.
        /// </summary>
        /// <value>Namespace identifier.</value>
        [DataMember(Name="targetNamespaceId", EmitDefaultValue=false)]
        public string TargetNamespaceId { get; set; }

        /// <summary>
        /// Namespace identifier.
        /// </summary>
        /// <value>Namespace identifier.</value>
        [DataMember(Name="id", EmitDefaultValue=true)]
        public string Id { get; set; }

        /// <summary>
        /// A number that allows uint 32 values.
        /// </summary>
        /// <value>A number that allows uint 32 values.</value>
        [DataMember(Name="nonce", EmitDefaultValue=true)]
        public long Nonce { get; set; }

        /// <summary>
        /// - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
        /// </summary>
        /// <value>- 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. </value>
        [DataMember(Name="flags", EmitDefaultValue=true)]
        public int Flags { get; set; }

        /// <summary>
        /// Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
        /// </summary>
        /// <value>Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. </value>
        [DataMember(Name="divisibility", EmitDefaultValue=true)]
        public int Divisibility { get; set; }

        /// <summary>
        /// Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
        /// </summary>
        /// <value>Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).</value>
        [DataMember(Name="delta", EmitDefaultValue=true)]
        public string Delta { get; set; }


        /// <summary>
        /// Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
        /// </summary>
        /// <value>Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA </value>
        [DataMember(Name="sourceAddress", EmitDefaultValue=true)]
        public string SourceAddress { get; set; }

        /// <summary>
        /// Namespace identifier.
        /// </summary>
        /// <value>Namespace identifier.</value>
        [DataMember(Name="parentId", EmitDefaultValue=false)]
        public string ParentId { get; set; }


        /// <summary>
        /// Namespace name.
        /// </summary>
        /// <value>Namespace name.</value>
        [DataMember(Name="name", EmitDefaultValue=true)]
        public string Name { get; set; }

        /// <summary>
        /// Namespace identifier.
        /// </summary>
        /// <value>Namespace identifier.</value>
        [DataMember(Name="namespaceId", EmitDefaultValue=true)]
        public string NamespaceId { get; set; }

        /// <summary>
        /// Address encoded using a 32-character set.
        /// </summary>
        /// <value>Address encoded using a 32-character set.</value>
        [DataMember(Name="address", EmitDefaultValue=true)]
        public string Address { get; set; }


        /// <summary>
        /// Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
        /// </summary>
        /// <value>Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. </value>
        [DataMember(Name="minRemovalDelta", EmitDefaultValue=true)]
        public int MinRemovalDelta { get; set; }

        /// <summary>
        /// Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
        /// </summary>
        /// <value>Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. </value>
        [DataMember(Name="minApprovalDelta", EmitDefaultValue=true)]
        public int MinApprovalDelta { get; set; }

        /// <summary>
        /// Array of cosignatory accounts to add.
        /// </summary>
        /// <value>Array of cosignatory accounts to add.</value>
        [DataMember(Name="addressAdditions", EmitDefaultValue=true)]
        public List<string> AddressAdditions { get; set; }

        /// <summary>
        /// Array of cosignatory accounts to delete.
        /// </summary>
        /// <value>Array of cosignatory accounts to delete.</value>
        [DataMember(Name="addressDeletions", EmitDefaultValue=true)]
        public List<string> AddressDeletions { get; set; }


        /// <summary>
        /// Account restriction additions.
        /// </summary>
        /// <value>Account restriction additions.</value>
        [DataMember(Name="restrictionAdditions", EmitDefaultValue=true)]
        public List<TransactionTypeEnum> RestrictionAdditions { get; set; }

        /// <summary>
        /// Account restriction deletions.
        /// </summary>
        /// <value>Account restriction deletions.</value>
        [DataMember(Name="restrictionDeletions", EmitDefaultValue=true)]
        public List<TransactionTypeEnum> RestrictionDeletions { get; set; }

        /// <summary>
        /// Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
        /// </summary>
        /// <value>Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. </value>
        [DataMember(Name="referenceMosaicId", EmitDefaultValue=true)]
        public string ReferenceMosaicId { get; set; }

        /// <summary>
        /// Restriction key.
        /// </summary>
        /// <value>Restriction key.</value>
        [DataMember(Name="restrictionKey", EmitDefaultValue=true)]
        public string RestrictionKey { get; set; }

        /// <summary>
        /// Restriction value.
        /// </summary>
        /// <value>Restriction value.</value>
        [DataMember(Name="previousRestrictionValue", EmitDefaultValue=true)]
        public string PreviousRestrictionValue { get; set; }

        /// <summary>
        /// Restriction value.
        /// </summary>
        /// <value>Restriction value.</value>
        [DataMember(Name="newRestrictionValue", EmitDefaultValue=true)]
        public string NewRestrictionValue { get; set; }



        /// <summary>
        /// Array of mosaics sent to the recipient. 
        /// </summary>
        /// <value>Array of mosaics sent to the recipient. </value>
        [DataMember(Name="mosaics", EmitDefaultValue=true)]
        public List<UnresolvedMosaic> Mosaics { get; set; }

        /// <summary>
        /// Transfer transaction message
        /// </summary>
        /// <value>Transfer transaction message</value>
        [DataMember(Name="message", EmitDefaultValue=false)]
        public string Message { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TransactionInfoDTOTransaction {\n");
            sb.Append("  Size: ").Append(Size).Append("\n");
            sb.Append("  Signature: ").Append(Signature).Append("\n");
            sb.Append("  SignerPublicKey: ").Append(SignerPublicKey).Append("\n");
            sb.Append("  _Version: ").Append(_Version).Append("\n");
            sb.Append("  Network: ").Append(Network).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  MaxFee: ").Append(MaxFee).Append("\n");
            sb.Append("  Deadline: ").Append(Deadline).Append("\n");
            sb.Append("  LinkedPublicKey: ").Append(LinkedPublicKey).Append("\n");
            sb.Append("  LinkAction: ").Append(LinkAction).Append("\n");
            sb.Append("  StartEpoch: ").Append(StartEpoch).Append("\n");
            sb.Append("  EndEpoch: ").Append(EndEpoch).Append("\n");
            sb.Append("  TransactionsHash: ").Append(TransactionsHash).Append("\n");
            sb.Append("  Cosignatures: ").Append(Cosignatures).Append("\n");
            sb.Append("  Transactions: ").Append(Transactions).Append("\n");
            sb.Append("  MosaicId: ").Append(MosaicId).Append("\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  Hash: ").Append(Hash).Append("\n");
            sb.Append("  RecipientAddress: ").Append(RecipientAddress).Append("\n");
            sb.Append("  Secret: ").Append(Secret).Append("\n");
            sb.Append("  HashAlgorithm: ").Append(HashAlgorithm).Append("\n");
            sb.Append("  Proof: ").Append(Proof).Append("\n");
            sb.Append("  TargetAddress: ").Append(TargetAddress).Append("\n");
            sb.Append("  ScopedMetadataKey: ").Append(ScopedMetadataKey).Append("\n");
            sb.Append("  ValueSizeDelta: ").Append(ValueSizeDelta).Append("\n");
            sb.Append("  ValueSize: ").Append(ValueSize).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("  TargetMosaicId: ").Append(TargetMosaicId).Append("\n");
            sb.Append("  TargetNamespaceId: ").Append(TargetNamespaceId).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Nonce: ").Append(Nonce).Append("\n");
            sb.Append("  Flags: ").Append(Flags).Append("\n");
            sb.Append("  Divisibility: ").Append(Divisibility).Append("\n");
            sb.Append("  Delta: ").Append(Delta).Append("\n");
            sb.Append("  Action: ").Append(Action).Append("\n");
            sb.Append("  SourceAddress: ").Append(SourceAddress).Append("\n");
            sb.Append("  ParentId: ").Append(ParentId).Append("\n");
            sb.Append("  RegistrationType: ").Append(RegistrationType).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  NamespaceId: ").Append(NamespaceId).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  AliasAction: ").Append(AliasAction).Append("\n");
            sb.Append("  MinRemovalDelta: ").Append(MinRemovalDelta).Append("\n");
            sb.Append("  MinApprovalDelta: ").Append(MinApprovalDelta).Append("\n");
            sb.Append("  AddressAdditions: ").Append(AddressAdditions).Append("\n");
            sb.Append("  AddressDeletions: ").Append(AddressDeletions).Append("\n");
            sb.Append("  RestrictionFlags: ").Append(RestrictionFlags).Append("\n");
            sb.Append("  RestrictionAdditions: ").Append(RestrictionAdditions).Append("\n");
            sb.Append("  RestrictionDeletions: ").Append(RestrictionDeletions).Append("\n");
            sb.Append("  ReferenceMosaicId: ").Append(ReferenceMosaicId).Append("\n");
            sb.Append("  RestrictionKey: ").Append(RestrictionKey).Append("\n");
            sb.Append("  PreviousRestrictionValue: ").Append(PreviousRestrictionValue).Append("\n");
            sb.Append("  NewRestrictionValue: ").Append(NewRestrictionValue).Append("\n");
            sb.Append("  PreviousRestrictionType: ").Append(PreviousRestrictionType).Append("\n");
            sb.Append("  NewRestrictionType: ").Append(NewRestrictionType).Append("\n");
            sb.Append("  Mosaics: ").Append(Mosaics).Append("\n");
            sb.Append("  Message: ").Append(Message).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TransactionInfoDTOTransaction);
        }

        /// <summary>
        /// Returns true if TransactionInfoDTOTransaction instances are equal
        /// </summary>
        /// <param name="input">Instance of TransactionInfoDTOTransaction to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TransactionInfoDTOTransaction input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Size == input.Size ||
                    (this.Size != null &&
                    this.Size.Equals(input.Size))
                ) && 
                (
                    this.Signature == input.Signature ||
                    (this.Signature != null &&
                    this.Signature.Equals(input.Signature))
                ) && 
                (
                    this.SignerPublicKey == input.SignerPublicKey ||
                    (this.SignerPublicKey != null &&
                    this.SignerPublicKey.Equals(input.SignerPublicKey))
                ) && 
                (
                    this._Version == input._Version ||
                    (this._Version != null &&
                    this._Version.Equals(input._Version))
                ) && 
                (
                    this.Network == input.Network ||
                    (this.Network != null &&
                    this.Network.Equals(input.Network))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.MaxFee == input.MaxFee ||
                    (this.MaxFee != null &&
                    this.MaxFee.Equals(input.MaxFee))
                ) && 
                (
                    this.Deadline == input.Deadline ||
                    (this.Deadline != null &&
                    this.Deadline.Equals(input.Deadline))
                ) && 
                (
                    this.LinkedPublicKey == input.LinkedPublicKey ||
                    (this.LinkedPublicKey != null &&
                    this.LinkedPublicKey.Equals(input.LinkedPublicKey))
                ) && 
                (
                    this.LinkAction == input.LinkAction ||
                    (this.LinkAction != null &&
                    this.LinkAction.Equals(input.LinkAction))
                ) && 
                (
                    this.StartEpoch == input.StartEpoch ||
                    (this.StartEpoch != null &&
                    this.StartEpoch.Equals(input.StartEpoch))
                ) && 
                (
                    this.EndEpoch == input.EndEpoch ||
                    (this.EndEpoch != null &&
                    this.EndEpoch.Equals(input.EndEpoch))
                ) && 
                (
                    this.TransactionsHash == input.TransactionsHash ||
                    (this.TransactionsHash != null &&
                    this.TransactionsHash.Equals(input.TransactionsHash))
                ) && 
                (
                    this.Cosignatures == input.Cosignatures ||
                    this.Cosignatures != null &&
                    input.Cosignatures != null &&
                    this.Cosignatures.SequenceEqual(input.Cosignatures)
                ) && 
                (
                    this.Transactions == input.Transactions ||
                    this.Transactions != null &&
                    input.Transactions != null &&
                    this.Transactions.SequenceEqual(input.Transactions)
                ) && 
                (
                    this.MosaicId == input.MosaicId ||
                    (this.MosaicId != null &&
                    this.MosaicId.Equals(input.MosaicId))
                ) && 
                (
                    this.Amount == input.Amount ||
                    (this.Amount != null &&
                    this.Amount.Equals(input.Amount))
                ) && 
                (
                    this.Duration == input.Duration ||
                    (this.Duration != null &&
                    this.Duration.Equals(input.Duration))
                ) && 
                (
                    this.Hash == input.Hash ||
                    (this.Hash != null &&
                    this.Hash.Equals(input.Hash))
                ) && 
                (
                    this.RecipientAddress == input.RecipientAddress ||
                    (this.RecipientAddress != null &&
                    this.RecipientAddress.Equals(input.RecipientAddress))
                ) && 
                (
                    this.Secret == input.Secret ||
                    (this.Secret != null &&
                    this.Secret.Equals(input.Secret))
                ) && 
                (
                    this.HashAlgorithm == input.HashAlgorithm ||
                    (this.HashAlgorithm != null &&
                    this.HashAlgorithm.Equals(input.HashAlgorithm))
                ) && 
                (
                    this.Proof == input.Proof ||
                    (this.Proof != null &&
                    this.Proof.Equals(input.Proof))
                ) && 
                (
                    this.TargetAddress == input.TargetAddress ||
                    (this.TargetAddress != null &&
                    this.TargetAddress.Equals(input.TargetAddress))
                ) && 
                (
                    this.ScopedMetadataKey == input.ScopedMetadataKey ||
                    (this.ScopedMetadataKey != null &&
                    this.ScopedMetadataKey.Equals(input.ScopedMetadataKey))
                ) && 
                (
                    this.ValueSizeDelta == input.ValueSizeDelta ||
                    (this.ValueSizeDelta != null &&
                    this.ValueSizeDelta.Equals(input.ValueSizeDelta))
                ) && 
                (
                    this.ValueSize == input.ValueSize ||
                    (this.ValueSize != null &&
                    this.ValueSize.Equals(input.ValueSize))
                ) && 
                (
                    this.Value == input.Value ||
                    (this.Value != null &&
                    this.Value.Equals(input.Value))
                ) && 
                (
                    this.TargetMosaicId == input.TargetMosaicId ||
                    (this.TargetMosaicId != null &&
                    this.TargetMosaicId.Equals(input.TargetMosaicId))
                ) && 
                (
                    this.TargetNamespaceId == input.TargetNamespaceId ||
                    (this.TargetNamespaceId != null &&
                    this.TargetNamespaceId.Equals(input.TargetNamespaceId))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.Nonce == input.Nonce ||
                    (this.Nonce != null &&
                    this.Nonce.Equals(input.Nonce))
                ) && 
                (
                    this.Flags == input.Flags ||
                    (this.Flags != null &&
                    this.Flags.Equals(input.Flags))
                ) && 
                (
                    this.Divisibility == input.Divisibility ||
                    (this.Divisibility != null &&
                    this.Divisibility.Equals(input.Divisibility))
                ) && 
                (
                    this.Delta == input.Delta ||
                    (this.Delta != null &&
                    this.Delta.Equals(input.Delta))
                ) && 
                (
                    this.Action == input.Action ||
                    (this.Action != null &&
                    this.Action.Equals(input.Action))
                ) && 
                (
                    this.SourceAddress == input.SourceAddress ||
                    (this.SourceAddress != null &&
                    this.SourceAddress.Equals(input.SourceAddress))
                ) && 
                (
                    this.ParentId == input.ParentId ||
                    (this.ParentId != null &&
                    this.ParentId.Equals(input.ParentId))
                ) && 
                (
                    this.RegistrationType == input.RegistrationType ||
                    (this.RegistrationType != null &&
                    this.RegistrationType.Equals(input.RegistrationType))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.NamespaceId == input.NamespaceId ||
                    (this.NamespaceId != null &&
                    this.NamespaceId.Equals(input.NamespaceId))
                ) && 
                (
                    this.Address == input.Address ||
                    (this.Address != null &&
                    this.Address.Equals(input.Address))
                ) && 
                (
                    this.AliasAction == input.AliasAction ||
                    (this.AliasAction != null &&
                    this.AliasAction.Equals(input.AliasAction))
                ) && 
                (
                    this.MinRemovalDelta == input.MinRemovalDelta ||
                    (this.MinRemovalDelta != null &&
                    this.MinRemovalDelta.Equals(input.MinRemovalDelta))
                ) && 
                (
                    this.MinApprovalDelta == input.MinApprovalDelta ||
                    (this.MinApprovalDelta != null &&
                    this.MinApprovalDelta.Equals(input.MinApprovalDelta))
                ) && 
                (
                    this.AddressAdditions == input.AddressAdditions ||
                    this.AddressAdditions != null &&
                    input.AddressAdditions != null &&
                    this.AddressAdditions.SequenceEqual(input.AddressAdditions)
                ) && 
                (
                    this.AddressDeletions == input.AddressDeletions ||
                    this.AddressDeletions != null &&
                    input.AddressDeletions != null &&
                    this.AddressDeletions.SequenceEqual(input.AddressDeletions)
                ) && 
                (
                    this.RestrictionFlags == input.RestrictionFlags ||
                    (this.RestrictionFlags != null &&
                    this.RestrictionFlags.Equals(input.RestrictionFlags))
                ) && 
                (
                    this.RestrictionAdditions == input.RestrictionAdditions ||
                    this.RestrictionAdditions != null &&
                    input.RestrictionAdditions != null &&
                    this.RestrictionAdditions.SequenceEqual(input.RestrictionAdditions)
                ) && 
                (
                    this.RestrictionDeletions == input.RestrictionDeletions ||
                    this.RestrictionDeletions != null &&
                    input.RestrictionDeletions != null &&
                    this.RestrictionDeletions.SequenceEqual(input.RestrictionDeletions)
                ) && 
                (
                    this.ReferenceMosaicId == input.ReferenceMosaicId ||
                    (this.ReferenceMosaicId != null &&
                    this.ReferenceMosaicId.Equals(input.ReferenceMosaicId))
                ) && 
                (
                    this.RestrictionKey == input.RestrictionKey ||
                    (this.RestrictionKey != null &&
                    this.RestrictionKey.Equals(input.RestrictionKey))
                ) && 
                (
                    this.PreviousRestrictionValue == input.PreviousRestrictionValue ||
                    (this.PreviousRestrictionValue != null &&
                    this.PreviousRestrictionValue.Equals(input.PreviousRestrictionValue))
                ) && 
                (
                    this.NewRestrictionValue == input.NewRestrictionValue ||
                    (this.NewRestrictionValue != null &&
                    this.NewRestrictionValue.Equals(input.NewRestrictionValue))
                ) && 
                (
                    this.PreviousRestrictionType == input.PreviousRestrictionType ||
                    (this.PreviousRestrictionType != null &&
                    this.PreviousRestrictionType.Equals(input.PreviousRestrictionType))
                ) && 
                (
                    this.NewRestrictionType == input.NewRestrictionType ||
                    (this.NewRestrictionType != null &&
                    this.NewRestrictionType.Equals(input.NewRestrictionType))
                ) && 
                (
                    this.Mosaics == input.Mosaics ||
                    this.Mosaics != null &&
                    input.Mosaics != null &&
                    this.Mosaics.SequenceEqual(input.Mosaics)
                ) && 
                (
                    this.Message == input.Message ||
                    (this.Message != null &&
                    this.Message.Equals(input.Message))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Size != null)
                    hashCode = hashCode * 59 + this.Size.GetHashCode();
                if (this.Signature != null)
                    hashCode = hashCode * 59 + this.Signature.GetHashCode();
                if (this.SignerPublicKey != null)
                    hashCode = hashCode * 59 + this.SignerPublicKey.GetHashCode();
                if (this._Version != null)
                    hashCode = hashCode * 59 + this._Version.GetHashCode();
                if (this.Network != null)
                    hashCode = hashCode * 59 + this.Network.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.MaxFee != null)
                    hashCode = hashCode * 59 + this.MaxFee.GetHashCode();
                if (this.Deadline != null)
                    hashCode = hashCode * 59 + this.Deadline.GetHashCode();
                if (this.LinkedPublicKey != null)
                    hashCode = hashCode * 59 + this.LinkedPublicKey.GetHashCode();
                if (this.LinkAction != null)
                    hashCode = hashCode * 59 + this.LinkAction.GetHashCode();
                if (this.StartEpoch != null)
                    hashCode = hashCode * 59 + this.StartEpoch.GetHashCode();
                if (this.EndEpoch != null)
                    hashCode = hashCode * 59 + this.EndEpoch.GetHashCode();
                if (this.TransactionsHash != null)
                    hashCode = hashCode * 59 + this.TransactionsHash.GetHashCode();
                if (this.Cosignatures != null)
                    hashCode = hashCode * 59 + this.Cosignatures.GetHashCode();
                if (this.Transactions != null)
                    hashCode = hashCode * 59 + this.Transactions.GetHashCode();
                if (this.MosaicId != null)
                    hashCode = hashCode * 59 + this.MosaicId.GetHashCode();
                if (this.Amount != null)
                    hashCode = hashCode * 59 + this.Amount.GetHashCode();
                if (this.Duration != null)
                    hashCode = hashCode * 59 + this.Duration.GetHashCode();
                if (this.Hash != null)
                    hashCode = hashCode * 59 + this.Hash.GetHashCode();
                if (this.RecipientAddress != null)
                    hashCode = hashCode * 59 + this.RecipientAddress.GetHashCode();
                if (this.Secret != null)
                    hashCode = hashCode * 59 + this.Secret.GetHashCode();
                if (this.HashAlgorithm != null)
                    hashCode = hashCode * 59 + this.HashAlgorithm.GetHashCode();
                if (this.Proof != null)
                    hashCode = hashCode * 59 + this.Proof.GetHashCode();
                if (this.TargetAddress != null)
                    hashCode = hashCode * 59 + this.TargetAddress.GetHashCode();
                if (this.ScopedMetadataKey != null)
                    hashCode = hashCode * 59 + this.ScopedMetadataKey.GetHashCode();
                if (this.ValueSizeDelta != null)
                    hashCode = hashCode * 59 + this.ValueSizeDelta.GetHashCode();
                if (this.ValueSize != null)
                    hashCode = hashCode * 59 + this.ValueSize.GetHashCode();
                if (this.Value != null)
                    hashCode = hashCode * 59 + this.Value.GetHashCode();
                if (this.TargetMosaicId != null)
                    hashCode = hashCode * 59 + this.TargetMosaicId.GetHashCode();
                if (this.TargetNamespaceId != null)
                    hashCode = hashCode * 59 + this.TargetNamespaceId.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.Nonce != null)
                    hashCode = hashCode * 59 + this.Nonce.GetHashCode();
                if (this.Flags != null)
                    hashCode = hashCode * 59 + this.Flags.GetHashCode();
                if (this.Divisibility != null)
                    hashCode = hashCode * 59 + this.Divisibility.GetHashCode();
                if (this.Delta != null)
                    hashCode = hashCode * 59 + this.Delta.GetHashCode();
                if (this.Action != null)
                    hashCode = hashCode * 59 + this.Action.GetHashCode();
                if (this.SourceAddress != null)
                    hashCode = hashCode * 59 + this.SourceAddress.GetHashCode();
                if (this.ParentId != null)
                    hashCode = hashCode * 59 + this.ParentId.GetHashCode();
                if (this.RegistrationType != null)
                    hashCode = hashCode * 59 + this.RegistrationType.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.NamespaceId != null)
                    hashCode = hashCode * 59 + this.NamespaceId.GetHashCode();
                if (this.Address != null)
                    hashCode = hashCode * 59 + this.Address.GetHashCode();
                if (this.AliasAction != null)
                    hashCode = hashCode * 59 + this.AliasAction.GetHashCode();
                if (this.MinRemovalDelta != null)
                    hashCode = hashCode * 59 + this.MinRemovalDelta.GetHashCode();
                if (this.MinApprovalDelta != null)
                    hashCode = hashCode * 59 + this.MinApprovalDelta.GetHashCode();
                if (this.AddressAdditions != null)
                    hashCode = hashCode * 59 + this.AddressAdditions.GetHashCode();
                if (this.AddressDeletions != null)
                    hashCode = hashCode * 59 + this.AddressDeletions.GetHashCode();
                if (this.RestrictionFlags != null)
                    hashCode = hashCode * 59 + this.RestrictionFlags.GetHashCode();
                if (this.RestrictionAdditions != null)
                    hashCode = hashCode * 59 + this.RestrictionAdditions.GetHashCode();
                if (this.RestrictionDeletions != null)
                    hashCode = hashCode * 59 + this.RestrictionDeletions.GetHashCode();
                if (this.ReferenceMosaicId != null)
                    hashCode = hashCode * 59 + this.ReferenceMosaicId.GetHashCode();
                if (this.RestrictionKey != null)
                    hashCode = hashCode * 59 + this.RestrictionKey.GetHashCode();
                if (this.PreviousRestrictionValue != null)
                    hashCode = hashCode * 59 + this.PreviousRestrictionValue.GetHashCode();
                if (this.NewRestrictionValue != null)
                    hashCode = hashCode * 59 + this.NewRestrictionValue.GetHashCode();
                if (this.PreviousRestrictionType != null)
                    hashCode = hashCode * 59 + this.PreviousRestrictionType.GetHashCode();
                if (this.NewRestrictionType != null)
                    hashCode = hashCode * 59 + this.NewRestrictionType.GetHashCode();
                if (this.Mosaics != null)
                    hashCode = hashCode * 59 + this.Mosaics.GetHashCode();
                if (this.Message != null)
                    hashCode = hashCode * 59 + this.Message.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
